<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js InstancedMesh 后期处理描边示例</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #fff;
            font-family: sans-serif;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">
        点击模型查看发光描边效果 (Post-Processing OutlinePass)<br>
        实现方案：InstancedMesh + 同步矩阵的透明代理网格(Proxy Mesh)
    </div>
    
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // 引入后期处理所需的模块
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // 1. 场景初始化
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        // 添加一些雾效增加场景感
        scene.fog = new THREE.Fog(0x222222, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true }); // 注意：后期处理可能会覆盖原生的 antialias
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // 开启阴影贴图
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // 添加灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);

        // 添加一个地面
        const groundMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshStandardMaterial({ color: 0x333333, depthWrite: true })
        );
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = -2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // =========================================================================
        // 2. 创建 InstancedMesh (模拟数字孪生场景中的批量设备)
        // =========================================================================
        
        // 关键点：保存这个 geometry 引用，后面代理网格要用同一个
        const sharedGeometry = new THREE.BoxGeometry(1, 1, 1);
        // 让几何体中心稍微偏移一点，增加随机感
        sharedGeometry.translate(0, 0.5, 0); 

        const material = new THREE.MeshStandardMaterial({ 
            color: 0x0077ff,
            roughness: 0.3,
            metalness: 0.7
        });
        const count = 150;
        const instancedMesh = new THREE.InstancedMesh(sharedGeometry, material, count);
        instancedMesh.castShadow = true;
        instancedMesh.receiveShadow = true;

        // 随机分布实例
        const dummy = new THREE.Object3D();
        // 用于存储每个实例颜色的数组
        const colors = [];
        const color = new THREE.Color();

        for (let i = 0; i < count; i++) {
            dummy.position.set(
                (Math.random() - 0.5) * 30,
                0, // 贴地放置
                (Math.random() - 0.5) * 30
            );
            dummy.rotation.set(
                0,
                Math.random() * Math.PI * 2,
                0
            );
            dummy.scale.set(
                0.5 + Math.random() * 1.5,
                0.5 + Math.random() * 2.5, // 高度随机
                0.5 + Math.random() * 1.5
            );
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(i, dummy.matrix);

            // 设置随机颜色变体
            color.setHex(0x0077ff).offsetHSL(Math.random() * 0.1 - 0.05, 0, Math.random() * 0.2 - 0.1);
            instancedMesh.setColorAt(i, color);
        }
        instancedMesh.instanceMatrix.needsUpdate = true;
        instancedMesh.instanceColor.needsUpdate = true; 
        scene.add(instancedMesh);

        // =========================================================================
        // 3. 创建代理网格 (Proxy Mesh) - 用于欺骗 OutlinePass
        // =========================================================================
        
        // 使用与 InstancedMesh 相同的几何体
        // 使用一个不可见的材质。OutlinePass 仍然会渲染它的轮廓，但普通渲染通道看不到它。
        // 注意：material.visible = false 有时会导致 OutlinePass 忽略它。
        // 更好的做法是设置 transparent: true 和 opacity: 0，或者把 visible 设为 true 但不给它任何复杂的材质属性。
        // OutlinePass 实际上并不关心代理 Mesh 的材质长什么样，它只关心几何体。
        const proxyMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            transparent: true,
            opacity: 0, // 完全透明
            depthWrite: false, // 不写入深度缓冲区
            depthTest: false // 不进行深度测试 (确保轮廓总是在最前面，如果需要)
        });

        const proxyMesh = new THREE.Mesh(sharedGeometry, proxyMaterial);
        
        // 关键：关闭自动矩阵更新。我们将手动将 Instance 的矩阵复制给它。
        proxyMesh.matrixAutoUpdate = false; 
        // 初始状态设为不可见，这样 OutlinePass 就不会处理它
        proxyMesh.visible = false; 
        // 必须添加到场景中，否则 OutlinePass 找不到它
        scene.add(proxyMesh);


        // =========================================================================
        // 4. 后期处理设置 (EffectComposer + OutlinePass)
        // =========================================================================
        
        const composer = new EffectComposer(renderer);
        
        // 添加基础渲染通道
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // 添加描边通道
        const outlinePass = new OutlinePass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            scene, 
            camera
        );
        
        // 配置描边参数
        outlinePass.edgeStrength = 4.0;   // 边缘强度/亮度
        outlinePass.edgeGlow = 1.0;       // 发光扩散范围
        outlinePass.edgeThickness = 1.5;  // 边缘厚度 (对于很细的线可能效果不明显)
        outlinePass.pulsePeriod = 2;      // 呼吸闪烁周期 (秒)，0 为常亮
        outlinePass.visibleEdgeColor.set('#00ffff'); // 可见部分的颜色 (青色)
        outlinePass.hiddenEdgeColor.set('#0088ff');  // 被遮挡部分的颜色
        
        composer.addPass(outlinePass);

        // 添加色彩校正/输出通道 (在较新版本的 Three.js 中用于正确处理 sRGB)
        const outputPass = new OutputPass();
        composer.addPass(outputPass);

        // =========================================================================
        // 5. 交互逻辑 (Raycaster)
        // =========================================================================

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        // 用于临时存储矩阵的变量
        const _instanceMatrix = new THREE.Matrix4();

        window.addEventListener('click', onMouseClick, false);

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // 检测与 InstancedMesh 的碰撞
            const intersection = raycaster.intersectObject(instancedMesh);

            if (intersection.length > 0) {
                const instanceId = intersection[0].instanceId;
                console.log(`选中 Instance ID: ${instanceId}`);

                // A. 获取被选中实例的矩阵
                instancedMesh.getMatrixAt(instanceId, _instanceMatrix);

                // B. 将矩阵应用到代理网格
                proxyMesh.matrix.copy(_instanceMatrix);
                // 确保代理网格对 OutlinePass 可见
                proxyMesh.visible = true; 

                // C. 告诉 OutlinePass 渲染这个代理网格
                outlinePass.selectedObjects = [proxyMesh];

            } else {
                // 点击空白处，清空选中
                console.log("取消选中");
                outlinePass.selectedObjects = [];
                // 隐藏代理网格
                proxyMesh.visible = false;
            }
        }

        // =========================================================================
        // 6. 渲染循环
        // =========================================================================

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // 重要：使用 composer.render() 代替 renderer.render()
            composer.render();
        }
        
        // 窗口大小自适应
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            // 重要：同时更新 composer 和 outlinePass 的尺寸
            composer.setSize(width, height);
            outlinePass.setSize(width, height);
        }

        animate();
    </script>
</body>
</html>