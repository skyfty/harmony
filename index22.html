<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js + Cannon-es 小车演示</title>
    <style>
        :root {
            color-scheme: dark;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at top, #1c2a44 0%, #0a0f1c 60%, #05060b 100%);
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            color: #e5f2ff;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            background: rgba(8, 12, 20, 0.78);
            border: 1px solid rgba(93, 163, 255, 0.35);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.55);
            border-radius: 12px;
            padding: 18px 20px;
            backdrop-filter: blur(12px);
            z-index: 10;
            pointer-events: none;
        }

        #info-panel h1 {
            margin: 0 0 12px;
            font-size: 20px;
            letter-spacing: 0.08em;
            color: #7cd8ff;
        }

        #info-panel p {
            margin: 0 0 16px;
            font-size: 13px;
            line-height: 1.5;
            color: #c7d7ff;
        }

        #info-panel ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 10px 12px;
        }

        #info-panel li {
            font-size: 13px;
        }

        .key {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
            padding: 2px 8px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.08);
            margin-right: 8px;
            font-family: "JetBrains Mono", "Fira Code", monospace;
            font-size: 12px;
        }

        #hint {
            margin-top: 12px;
            font-size: 12px;
            color: #6f8bbf;
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h1>刚体长方体小车</h1>
        <p>示范如何使用 Three.js 同步 Cannon-es 物理，利用键盘控制一个简易长方体车辆。</p>
        <ul>
            <li><span class="key">W</span>/<span class="key">↑</span>前进</li>
            <li><span class="key">S</span>/<span class="key">↓</span>后退</li>
            <li><span class="key">A</span>/<span class="key">←</span>左转</li>
            <li><span class="key">D</span>/<span class="key">→</span>右转</li>
            <li><span class="key">Space</span>刹车</li>
            <li><span class="key">鼠标</span>环视</li>
        </ul>
        <div id="hint">提示：旋转视角可观察到物理形变与 mesh 同步。</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import Stats from 'three/addons/libs/stats.module.js';
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050b16);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(6, 4, 8);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 1, 0);

        const hemiLight = new THREE.HemisphereLight(0xc7d9ff, 0x0f1c2e, 1.2);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
        dirLight.position.set(5, 8, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x1d2233, metalness: 0.05, roughness: 0.9 });
        const groundMesh = new THREE.Mesh(new THREE.BoxGeometry(200, 0.4, 200), groundMaterial);
        groundMesh.receiveShadow = true;
        groundMesh.position.y = -0.2;
        scene.add(groundMesh);
        const gridHelper = new THREE.GridHelper(200, 40, 0x375077, 0x162032);
        scene.add(gridHelper);

        const referenceGroup = new THREE.Group();
        scene.add(referenceGroup);

        const pillarGeometry = new THREE.CylinderGeometry(0.35, 0.45, 2.6, 18);
        const beamGeometry = new THREE.BoxGeometry(3.6, 0.25, 0.5);
        const pillarMaterial = new THREE.MeshStandardMaterial({ color: 0x7cd8ff, metalness: 0.35, roughness: 0.4 });
        const beamMaterial = new THREE.MeshStandardMaterial({ color: 0xffa14a, metalness: 0.2, roughness: 0.6 });
        const gatePositions = [-8, -18, -28];
        gatePositions.forEach((z, index) => {
            const leftPillar = new THREE.Mesh(pillarGeometry, pillarMaterial.clone());
            const rightPillar = new THREE.Mesh(pillarGeometry, pillarMaterial.clone());
            const beam = new THREE.Mesh(beamGeometry, beamMaterial.clone());
            leftPillar.position.set(-1.8, 1.3, z);
            rightPillar.position.set(1.8, 1.3, z);
            beam.position.set(0, 2.5, z);
            const hueShift = 0.15 * index;
            leftPillar.material.color.offsetHSL(hueShift, 0, 0);
            rightPillar.material.color.offsetHSL(hueShift, 0, 0);
            beam.material.color.offsetHSL(hueShift, 0, 0);
            referenceGroup.add(leftPillar, rightPillar, beam);
        });

        const coneGeometry = new THREE.ConeGeometry(0.28, 0.7, 14);
        const coneMaterial = new THREE.MeshStandardMaterial({ color: 0xff5563, roughness: 0.55 });
        for (let i = 0; i < 10; i++) {
            const cone = new THREE.Mesh(coneGeometry, coneMaterial.clone());
            const spacing = 3.5;
            const offset = -i * spacing - 4;
            const lateral = (i % 2 === 0 ? -2.4 : 2.4);
            cone.position.set(lateral, 0.35, offset);
            cone.castShadow = true;
            referenceGroup.add(cone);
        }

        const stats = new Stats();
        document.body.appendChild(stats.dom);

        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
        world.broadphase = new CANNON.NaiveBroadphase();
        world.allowSleep = true;

        const groundMaterialPhysics = new CANNON.Material('ground');
        const tireMaterial = new CANNON.Material('tire');
        const defaultContact = new CANNON.ContactMaterial(tireMaterial, groundMaterialPhysics, {
            friction: 1.4,
            restitution: 0.0,
            maxForce: 1e6,
            maxSlip: 0.9
        });
        world.addContactMaterial(defaultContact);

        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, shape: groundShape, material: groundMaterialPhysics });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        const carSize = { width: 1.6, height: 0.6, length: 3.0 };
        const chassisShape = new CANNON.Box(new CANNON.Vec3(carSize.width / 2, carSize.height / 2, carSize.length / 2));
        const chassisBody = new CANNON.Body({
            mass: 60,
            position: new CANNON.Vec3(0, 1, 0),
            linearDamping: 0.25,
            angularDamping: 0.72,
            material: tireMaterial
        });
        chassisBody.addShape(chassisShape, new CANNON.Vec3(0, -0.24, 0));
        chassisBody.updateMassProperties();
        world.addBody(chassisBody);
        chassisBody.allowSleep = false;

        const vehicle = new CANNON.RaycastVehicle({
            chassisBody,
            indexRightAxis: 0,
            indexUpAxis: 1,
            indexForwardAxis: 2
        });

        const wheelRadius = 0.4;
        const wheelHalfWidth = 0.25;
        const suspensionRestLength = 0.26;
        const wheelPositions = [
            new CANNON.Vec3(carSize.width / 2 - 0.2, 0, carSize.length / 2 - 0.5),
            new CANNON.Vec3(-carSize.width / 2 + 0.2, 0, carSize.length / 2 - 0.5),
            new CANNON.Vec3(carSize.width / 2 - 0.2, 0, -carSize.length / 2 + 0.5),
            new CANNON.Vec3(-carSize.width / 2 + 0.2, 0, -carSize.length / 2 + 0.5)
        ];

        const baseWheelOptions = {
            radius: wheelRadius,
            suspensionRestLength,
            suspensionStiffness: 30,
            dampingCompression: 11,
            dampingRelaxation: 8.5,
            frictionSlip: 2.35,
            maxSuspensionForce: 150000,
            maxSuspensionTravel: 0.26,
            rollInfluence: 0.03,
            axleLocal: new CANNON.Vec3(1, 0, 0),
            directionLocal: new CANNON.Vec3(0, -1, 0)
        };
        const frontSuspensionTuning = {
            suspensionStiffness: 32,
            dampingCompression: 12,
            dampingRelaxation: 9
        };
        const rearSuspensionTuning = {
            suspensionStiffness: 40,
            dampingCompression: 15,
            dampingRelaxation: 11
        };

        const frontWheelIndices = [];
        const rearWheelIndices = [];
        wheelPositions.forEach((position) => {
            vehicle.addWheel({
                ...baseWheelOptions,
                chassisConnectionPointLocal: new CANNON.Vec3(position.x, position.y, position.z)
            });
            const wheelIndex = vehicle.wheelInfos.length - 1;
            const wheelInfo = vehicle.wheelInfos[wheelIndex];
            if (position.z < 0) {
                Object.assign(wheelInfo, frontSuspensionTuning);
                frontWheelIndices.push(wheelIndex);
            } else {
                Object.assign(wheelInfo, rearSuspensionTuning);
                rearWheelIndices.push(wheelIndex);
            }
        });

        vehicle.addToWorld(world);

        const chassisMesh = new THREE.Mesh(
            new THREE.BoxGeometry(carSize.width, carSize.height, carSize.length),
            new THREE.MeshStandardMaterial({ color: 0x14b8f8, roughness: 0.35, metalness: 0.45 })
        );
        chassisMesh.castShadow = true;
        scene.add(chassisMesh);

        const wheelMeshes = [];
        const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelHalfWidth * 2, 18);
        wheelGeometry.rotateZ(Math.PI / 2);
        const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0xe0e5ff, metalness: 0.3, roughness: 0.35 });
        vehicle.wheelInfos.forEach((_, index) => {
            const mesh = new THREE.Mesh(wheelGeometry, wheelMaterial.clone());
            mesh.castShadow = true;
            scene.add(mesh);
            wheelMeshes[index] = mesh;
        });

        const formatNumber = (value) => Number(value).toFixed(2);
        const formatVec3 = (vec3) => `${formatNumber(vec3.x)}, ${formatNumber(vec3.y)}, ${formatNumber(vec3.z)}`;

        const input = { forward: 0, turn: 0, brake: false };
        const wakeVehicle = (reason) => {
            if (chassisBody.sleepState !== CANNON.Body.AWAKE) {
                chassisBody.wakeUp();
                console.log(`[wake] ${reason}`);
            }
        };
        const logInputState = (source) => {
            console.log(`[input:${source}]`, { ...input });
        };
        const keyBindings = {
            KeyW: () => input.forward = 1,
            ArrowUp: () => input.forward = 1,
            KeyS: () => input.forward = -1,
            ArrowDown: () => input.forward = -1,
            KeyA: () => input.turn = 1,
            ArrowLeft: () => input.turn = 1,
            KeyD: () => input.turn = -1,
            ArrowRight: () => input.turn = -1
        };

        const keyReset = {
            KeyW: () => input.forward = 0,
            ArrowUp: () => input.forward = 0,
            KeyS: () => input.forward = 0,
            ArrowDown: () => input.forward = 0,
            KeyA: () => input.turn = 0,
            ArrowLeft: () => input.turn = 0,
            KeyD: () => input.turn = 0,
            ArrowRight: () => input.turn = 0
        };

        window.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                input.brake = true;
                wakeVehicle('space');
                logInputState('space-down');
                return;
            }
            if (keyBindings[event.code]) {
                keyBindings[event.code]();
                wakeVehicle(event.code);
                logInputState(event.code);
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.code === 'Space') {
                input.brake = false;
                logInputState('space-up');
                return;
            }
            if (keyReset[event.code]) {
                keyReset[event.code]();
                logInputState(`${event.code}-up`);
            }
        });

        const tmpThreePosition = new THREE.Vector3();
        const tmpThreeQuaternion = new THREE.Quaternion();
        const lastDriveState = { engine: 0, steer: 0, brake: 0 };

        const engineForceMax = 1000;
        const steeringAngle = Math.PI / 6;
        const brakeForceFront = 115;
        const brakeForceRear = 80;
        const throttleResponse = 7;
        let engineForceApplied = 0;

        function updateVehicleControls(delta) {
            const targetEngine = engineForceMax * input.forward;
            const lerpFactor = Math.min(delta * throttleResponse, 1);
            engineForceApplied += (targetEngine - engineForceApplied) * lerpFactor;
            const steer = steeringAngle * input.turn;
            const braking = input.brake;
            const frontBrake = braking ? brakeForceFront : 0;
            const rearBrake = braking ? brakeForceRear : 0;

            frontWheelIndices.forEach((index) => {
                vehicle.applyEngineForce(0, index);
                vehicle.setSteeringValue(steer, index);
                vehicle.setBrake(frontBrake, index);
            });
            rearWheelIndices.forEach((index) => {
                vehicle.applyEngineForce(braking ? 0 : engineForceApplied, index);
                vehicle.setSteeringValue(0, index);
                vehicle.setBrake(rearBrake, index);
            });

            lastDriveState.engine = engineForceApplied;
            lastDriveState.steer = steer;
            lastDriveState.brake = Math.max(frontBrake, rearBrake);
        }

        function syncGraphics() {
            tmpThreePosition.set(chassisBody.position.x, chassisBody.position.y, chassisBody.position.z);
            tmpThreeQuaternion.set(chassisBody.quaternion.x, chassisBody.quaternion.y, chassisBody.quaternion.z, chassisBody.quaternion.w);
            chassisMesh.position.copy(tmpThreePosition);
            chassisMesh.quaternion.copy(tmpThreeQuaternion);
        }

        function syncWheelMeshes() {
            vehicle.wheelInfos.forEach((wheel, index) => {
                vehicle.updateWheelTransform(index);
                const transform = wheel.worldTransform;
                const mesh = wheelMeshes[index];
                if (!mesh) return;
                mesh.position.set(transform.position.x, transform.position.y, transform.position.z);
                mesh.quaternion.set(transform.quaternion.x, transform.quaternion.y, transform.quaternion.z, transform.quaternion.w);
            });
        }

        const fixedTimeStep = 1 / 60;
        const maxSubSteps = 3;
        let lastTime;
        let frameCounter = 0;
        const stateLogInterval = 60;
        const controlLogInterval = 15;

        console.log('[init] Cannon world ready', {
            mass: chassisBody.mass,
            startPosition: formatVec3(chassisBody.position)
        });

        function animate(time) {
            requestAnimationFrame(animate);
            if (lastTime !== undefined) {
                const delta = (time - lastTime) / 1000;
                updateVehicleControls(delta);
                world.step(fixedTimeStep, delta, maxSubSteps);
                syncGraphics();
                syncWheelMeshes();
            }
            lastTime = time;
            frameCounter++;
            if ((input.forward !== 0 || input.turn !== 0 || input.brake) && frameCounter % controlLogInterval === 0) {
                console.log(`[control] forward=${input.forward} turn=${input.turn} brake=${input.brake} engine=${formatNumber(lastDriveState.engine)} steer=${formatNumber(lastDriveState.steer)} brakeForce=${formatNumber(lastDriveState.brake)} vel=${formatVec3(chassisBody.velocity)}`);
            }
            if (frameCounter % stateLogInterval === 0) {
                console.log(`[state] t=${(time / 1000).toFixed(2)}s pos=${formatVec3(chassisBody.position)} vel=${formatVec3(chassisBody.velocity)} speed=${formatNumber(chassisBody.velocity.length())}`);
            }
            controls.update();
            stats.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>