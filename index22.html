<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js + Cannon-es 小车演示</title>
    
</head>
<body>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import Stats from 'three/addons/libs/stats.module.js';
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0d1117);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(6, 4, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const stats = new Stats();
        document.body.appendChild(stats.dom);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.enableDamping = true;
        controls.enabled = false;

        const hemiLight = new THREE.HemisphereLight(0xbbe6ff, 0x0f1b28, 0.6);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        scene.add(dirLight);
        const fillLight = new THREE.PointLight(0x67b3ff, 0.4, 25, 2);
        fillLight.position.set(-6, 3, 2);
        scene.add(fillLight);
        const rimLight = new THREE.SpotLight(0xffa000, 1.1, 40, Math.PI / 5, 0.4, 0.8);
        rimLight.position.set(0, 8, -6);
        rimLight.target.position.set(0, 0, 0);
        rimLight.castShadow = true;
        scene.add(rimLight);
        scene.add(rimLight.target);

        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.allowSleep = true;
        world.defaultContactMaterial.friction = 0.4;
        world.defaultContactMaterial.restitution = 0.05;

        const groundMaterial = new CANNON.Material('ground');
        const carMaterial = new CANNON.Material('car');
        const contactMat = new CANNON.ContactMaterial(groundMaterial, carMaterial, {
            friction: 0.8,
            restitution: 0.0,
        });
        world.addContactMaterial(contactMat);

        const groundGeo = new THREE.PlaneGeometry(200, 200, 20, 20);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x1f2933, metalness: 0.0, roughness: 0.9, wireframe: false });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.receiveShadow = true;
        groundMesh.rotation.x = -Math.PI / 2;
        scene.add(groundMesh);

        const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
        groundBody.addShape(new CANNON.Plane());
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        const obstacleGroup = new THREE.Group();
        scene.add(obstacleGroup);

        const obstacleDefs = [
            { position: [3, 0.5, -3], size: [1.2, 1, 1], color: 0x5d5fef },
            { position: [-2, 0.3, 2], size: [0.8, 0.6, 0.8], color: 0x34d399 },
            { position: [0, 0.8, 4], size: [1.5, 1.4, 0.9], color: 0xf97316 },
        ];
        obstacleDefs.forEach((def) => {
            const [x, y, z] = def.position;
            const [sx, sy, sz] = def.size;
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(sx, sy, sz),
                new THREE.MeshStandardMaterial({ color: def.color, roughness: 0.6, metalness: 0.05 })
            );
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.position.set(x, y, z);
            obstacleGroup.add(mesh);

            const halfExtents = new CANNON.Vec3(sx / 2, sy / 2, sz / 2);
            const shape = new CANNON.Box(halfExtents);
            const body = new CANNON.Body({ mass: 0, material: groundMaterial });
            body.addShape(shape);
            body.position.set(x, y, z);
            world.addBody(body);
        });

        const carGroup = new THREE.Group();
        scene.add(carGroup);

        const bodySize = { width: 1.4, height: 0.6, length: 2.6 };
        const wheelRadius = 0.5;
        const wheelWidth = 0.2;
        const centerOfMassOffset = new CANNON.Vec3(0, 0.12, -0.08);

        const chassisMesh = new THREE.Mesh(
            new THREE.BoxGeometry(bodySize.width, bodySize.height, bodySize.length),
            new THREE.MeshStandardMaterial({ color: 0xff7043, roughness: 0.5, metalness: 0.1 })
        );
        chassisMesh.castShadow = true;
        chassisMesh.position.set(centerOfMassOffset.x, centerOfMassOffset.y, centerOfMassOffset.z);
        carGroup.add(chassisMesh);

        const wheelGeo = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth, 20);
        wheelGeo.rotateZ(Math.PI / 2);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.3, roughness: 0.4 });
        const wheelOffsets = [
            { x: bodySize.width / 2 + 0.02, z: bodySize.length / 2 - 0.18 },
            { x: -bodySize.width / 2 - 0.02, z: bodySize.length / 2 - 0.18 },
            { x: bodySize.width / 2 + 0.02, z: -bodySize.length / 2 + 0.18 },
            { x: -bodySize.width / 2 - 0.02, z: -bodySize.length / 2 + 0.18 },
        ];
        const wheelMeshes = [];

        const chassisShape = new CANNON.Box(new CANNON.Vec3(bodySize.width / 2, bodySize.height / 2, bodySize.length / 2));
        const chassisBody = new CANNON.Body({
            mass: 120,
            material: carMaterial,
            angularDamping: 0.85,
            linearDamping: 0.25,
            position: new CANNON.Vec3(0, wheelRadius + bodySize.height / 2, 0),
        });
        chassisBody.addShape(chassisShape, centerOfMassOffset);
        world.addBody(chassisBody);

        const raycastVehicle = new CANNON.RaycastVehicle({
            chassisBody,
            indexRightAxis: 0,
            indexUpAxis: 1,
            indexForwardAxis: 2,
        });
        const connectionHeight = -bodySize.height / 2 + 0.05;
        const frontConnectionHeight = connectionHeight + 0.04;
        const rearConnectionHeight = connectionHeight - 0.02;
        const directionLocal = new CANNON.Vec3(0, -1, 0);
        const axleLocal = new CANNON.Vec3(-1, 0, 0);
        wheelOffsets.forEach((offset, index) => {
            const isFrontWheel = index < 2;
            const suspensionRestLength = isFrontWheel ? 0.26 : 0.3;
            const connectionY = isFrontWheel ? frontConnectionHeight : rearConnectionHeight;
            raycastVehicle.addWheel({
                radius: wheelRadius,
                directionLocal: directionLocal.clone(),
                axleLocal: axleLocal.clone(),
                suspensionRestLength,
                suspensionStiffness: 28,
                dampingRelaxation: 3.2,
                dampingCompression: 4.4,
                frictionSlip: 1.8,
                rollInfluence: isFrontWheel ? 0.04 : 0.06,
                maxSuspensionForce: 100000,
                maxSuspensionTravel: 0.35,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true,
                chassisConnectionPointLocal: new CANNON.Vec3(offset.x, connectionY, offset.z),
                isFrontWheel,
            });
            const wheel = new THREE.Mesh(wheelGeo, wheelMat);
            wheel.castShadow = true;
            scene.add(wheel);
            wheelMeshes.push(wheel);
        });
        raycastVehicle.addToWorld(world);
        const driveWheelIndices = [2, 3];
        const steerWheelIndices = [0, 1];
        const brakeWheelIndices = [0, 1, 2, 3];
        const ENGINE_FORCE = 1200;
        const ENGINE_RESPONSE = 7;
        const BRAKE_FORCE = 140;
        const BRAKE_RESPONSE = 9;
        const DOWNFORCE_COEFF = 55;
        const PITCH_STABILIZER = 55;
        const CAMERA_BACK_DISTANCE = 7;
        const CAMERA_UP_DISTANCE = 2.6;
        const CAMERA_SMOOTHNESS = 6;
        const axisVectors = [
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, 0, 1),
        ];
        const cameraDesired = new THREE.Vector3();
        const cameraLookTarget = new THREE.Vector3();
        const downforceForce = new CANNON.Vec3();
        const downforcePoint = new CANNON.Vec3(0, 0, bodySize.length * 0.25);
        const MAX_STEER_ANGLE = THREE.MathUtils.degToRad(28);
        let currentEngineForce = 0;
        let currentBrakeForce = 0;

        const instructions = document.createElement('div');
        instructions.style.position = 'absolute';
        instructions.style.top = '16px';
        instructions.style.left = '16px';
        instructions.style.padding = '10px 14px';
        instructions.style.background = 'rgba(13, 17, 23, 0.8)';
        instructions.style.color = '#f8fafc';
        instructions.style.fontFamily = 'monospace';
        instructions.style.fontSize = '14px';
        instructions.style.borderRadius = '6px';
        instructions.innerHTML = 'Controls: W/S drive · A/D steer · Space brake';
        document.body.appendChild(instructions);

        const keys = { forward: false, backward: false, left: false, right: false, brake: false };
        window.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    keys.forward = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    keys.backward = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    keys.left = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.right = true;
                    break;
                case 'Space':
                    keys.brake = true;
                    break;
            }
        });
        window.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    keys.forward = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    keys.backward = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'Space':
                    keys.brake = false;
                    break;
            }
        });

        const clock = new THREE.Clock();
        function smoothResponse(current, target, response, delta) {
            if (response <= 0) {
                return target;
            }
            const factor = 1 - Math.exp(-response * delta);
            return current + (target - current) * factor;
        }

        function applyControls(delta) {
            let engineForce = 0;
            if (keys.forward) {
                engineForce = -ENGINE_FORCE;
            } else if (keys.backward) {
                engineForce = ENGINE_FORCE * 0.6;
            }
            currentEngineForce = smoothResponse(currentEngineForce, engineForce, ENGINE_RESPONSE, delta);
            driveWheelIndices.forEach((index) => {
                raycastVehicle.applyEngineForce(currentEngineForce, index);
            });

            const steerValue = ((keys.left ? 1 : 0) - (keys.right ? 1 : 0)) * MAX_STEER_ANGLE;
            steerWheelIndices.forEach((index) => {
                raycastVehicle.setSteeringValue(steerValue, index);
            });

            const desiredBrake = keys.brake ? BRAKE_FORCE : 0;
            currentBrakeForce = smoothResponse(currentBrakeForce, desiredBrake, BRAKE_RESPONSE, delta);
            brakeWheelIndices.forEach((index) => {
                raycastVehicle.setBrake(currentBrakeForce, index);
            });
        }

        function applyDownforce() {
            const speed = chassisBody.velocity.length();
            if (speed < 0.5) {
                return;
            }
            downforceForce.set(0, -DOWNFORCE_COEFF * speed, 0);
            chassisBody.applyLocalForce(downforceForce, downforcePoint);
        }

        function applyPitchStabilizer() {
            const pitchVelocity = chassisBody.angularVelocity.x;
            if (Math.abs(pitchVelocity) < 0.005) {
                return;
            }
            chassisBody.torque.x -= pitchVelocity * PITCH_STABILIZER;
        }

        function getWorldAxis(axisIndex) {
            const base = axisVectors[axisIndex] || axisVectors[2];
            return base.clone().applyQuaternion(carGroup.quaternion).normalize();
        }

        function updateChaseCamera(delta) {
            const forwardWorld = getWorldAxis(raycastVehicle.indexForwardAxis ?? 2);
            const upWorld = getWorldAxis(raycastVehicle.indexUpAxis ?? 1);
            cameraDesired
                .copy(carGroup.position)
                .addScaledVector(forwardWorld, -CAMERA_BACK_DISTANCE)
                .addScaledVector(upWorld, CAMERA_UP_DISTANCE);
            const smooth = 1 - Math.exp(-CAMERA_SMOOTHNESS * delta);
            camera.position.lerp(cameraDesired, smooth);
            camera.up.copy(upWorld);
            cameraLookTarget.copy(carGroup.position).addScaledVector(forwardWorld, 2);
            camera.lookAt(cameraLookTarget);
        }

        function syncVisuals() {
            carGroup.position.copy(chassisBody.position);
            carGroup.quaternion.copy(chassisBody.quaternion);
        }

        function updateWheelVisuals() {
            raycastVehicle.wheelInfos.forEach((wheelInfo, index) => {
                raycastVehicle.updateWheelTransform(index);
                const transform = wheelInfo.worldTransform;
                const mesh = wheelMeshes[index];
                mesh.position.set(transform.position.x, transform.position.y, transform.position.z);
                mesh.quaternion.set(
                    transform.quaternion.x,
                    transform.quaternion.y,
                    transform.quaternion.z,
                    transform.quaternion.w
                );
            });
        }

        function animate() {
            const delta = clock.getDelta();
            applyControls(delta);
            applyDownforce();
            applyPitchStabilizer();
            world.step(1 / 60, delta, 3);
            syncVisuals();
            updateWheelVisuals();
            updateChaseCamera(delta);
            renderer.render(scene, camera);
            stats.update();
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        updateWheelVisuals();
        animate();
    </script>
</body>
</html>