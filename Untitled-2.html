<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Three.js 内部体积云 Skybox 实例</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">Three.js Procedural Skybox (Inside Sphere) <br> Drag to look around</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 场景设置 ---
        const scene = new THREE.Scene();
        
        // 相机位于中心
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 0, 0.1); // 稍微偏移一点点避免万一的奇异点，虽通常不需要

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // 控制器 (设置为“反向”观看体验，虽然OrbitControls默认是围绕物体转，
        // 但如果我们位于球心，它看起来就像是我们自己在转头)
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableZoom = false; // 天空盒通常不需要缩放
        controls.enablePan = false;
        controls.rotateSpeed = -0.25; // 反转拖拽方向，模拟“第一人称”视角的感觉

        // --- Shader 代码 ---

        const vertexShader = `
            varying vec3 vWorldPosition;
            varying vec3 vSunDirection;
            varying vec2 vUv;

            void main() {
                vUv = uv;
                // 获取世界坐标，用于计算天空梯度和噪声采样
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform float uTime;
            uniform vec3 uSunPos; // 太阳在世界坐标中的位置

            varying vec3 vWorldPosition;
            varying vec2 vUv;

            // --- 噪声函数库 (Simplex Noise 3D) ---
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

                // First corner
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;

                // Other corners
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );

                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;

                i = mod289(i);
                vec4 p = permute( permute( permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;

                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );

                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);

                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );

                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));

                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);

                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;

                vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                            dot(p2,x2), dot(p3,x3) ) );
            }

            // --- FBM: 生成云的细节 ---
            float fbm(vec3 p) {
                float sum = 0.0;
                float amp = 0.5;
                float freq = 1.0;
                // 5层倍频
                for(int i = 0; i < 5; i++) {
                    sum += snoise(p * freq) * amp;
                    freq *= 2.02; // 稍微不是2.0，避免网格伪影
                    amp *= 0.5;
                }
                return sum;
            }

            void main() {
                // 归一化的视线方向
                vec3 viewDir = normalize(vWorldPosition);
                vec3 sunDir = normalize(uSunPos);

                // --- 1. 绘制天空背景 (大气散射简化版) ---
                // 基于 viewDir.y (高度) 来决定颜色
                // 顶部深蓝 (0.0, 0.4, 0.8)，地平线浅白 (0.6, 0.8, 1.0)
                vec3 topColor = vec3(0.1, 0.4, 0.8);
                vec3 bottomColor = vec3(0.7, 0.8, 0.95);
                
                // 平滑过渡
                float skyMix = smoothstep(-0.2, 0.5, viewDir.y);
                vec3 skyColor = mix(bottomColor, topColor, skyMix);

                // --- 2. 绘制太阳光晕 ---
                float sunDot = dot(viewDir, sunDir);
                // 太阳核心极亮
                float sunCore = smoothstep(0.998, 0.999, sunDot); 
                // 太阳外围光晕
                float sunGlow = smoothstep(0.9, 1.0, sunDot) * 0.5;
                
                // 将太阳叠加到天空
                skyColor += vec3(1.0, 0.9, 0.7) * sunCore * 5.0; // 核心超亮
                skyColor += vec3(1.0, 0.8, 0.6) * sunGlow;

                // --- 3. 生成云层 ---
                // 采样坐标缩放：除以半径，或者直接缩放。
                // 加上时间偏移让云移动
                float cloudScale = 0.008; 
                vec3 cloudPos = vWorldPosition * cloudScale;
                cloudPos.x += uTime * 0.02; // 风吹动

                float noiseVal = fbm(cloudPos);

                // 将噪声映射到 [0, 1]
                noiseVal = noiseVal * 0.5 + 0.5;

                // --- 云层形状控制 ---
                // 越靠近地平线(viewDir.y 越小)，云层越应该变淡或者消失
                // 否则地平线会看起来像是一堵墙
                float horizonFade = smoothstep(0.0, 0.3, viewDir.y);
                
                // 阈值切割：决定云的多少
                float cloudCoverage = 0.55; 
                float cloudAlpha = smoothstep(cloudCoverage, cloudCoverage + 0.15, noiseVal);
                
                // 结合地平线淡出
                cloudAlpha *= horizonFade;

                // --- 云层颜色与光照 ---
                // 简单的光照模拟：如果是背光(对着太阳)，云中间黑边缘亮（银边效应）
                // 这里做一个简化版：
                vec3 cloudBaseColor = vec3(1.0); // 白云
                vec3 cloudShadowColor = vec3(0.7, 0.75, 0.8); // 阴影色

                // 根据太阳距离混合云的明暗
                // 靠近太阳的地方，云反而可能比较暗（因为厚），除非是边缘
                float lightIntensity = sunDot * 0.5 + 0.5; 
                vec3 finalCloudColor = mix(cloudShadowColor, cloudBaseColor, lightIntensity);
                
                // 银边效应 (Silver Lining) - 稍微复杂一点，增强靠近太阳边缘的云
                float silverLining = smoothstep(0.8, 1.0, sunDot) * (1.0 - cloudAlpha);
                finalCloudColor += vec3(1.0) * silverLining * 2.0;

                // --- 最终混合 ---
                // 使用 cloudAlpha 将云叠加到天空上
                vec3 finalColor = mix(skyColor, finalCloudColor, cloudAlpha);

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // --- 创建天空盒球体 ---
        // 半径设大一点，比如 500
        const skyGeo = new THREE.SphereGeometry(500, 60, 40);
        
        const skyMat = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uSunPos: { value: new THREE.Vector3(100, 200, -100) } // 太阳位置
            },
            side: THREE.BackSide // 关键：只渲染内表面
        });

        const skybox = new THREE.Mesh(skyGeo, skyMat);
        scene.add(skybox);

        // --- 动画循环 ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            skyMat.uniforms.uTime.value = t;

            // 让太阳缓慢移动（模拟日出日落的话需要改颜色逻辑，这里仅小范围移动演示）
            // skyMat.uniforms.uSunPos.value.x = Math.sin(t * 0.1) * 200;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // 窗口适配
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>