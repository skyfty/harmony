<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>cannon.js - RaycastVehicle</title>
    <link rel="stylesheet" href="css/style.css" type="text/css" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  </head>
  <body>
    <script type="module">
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

      // 初始化 Demo 实例
      const demo = new Demo()

      // 添加名为 'Car' 的场景
      demo.addScene('Car', () => {
        // 设置物理世界
        const world = setupWorld(demo)

        // --- 构建车身 ---
        // 创建车身形状 (Box)
        const chassisShape = new CANNON.Box(new CANNON.Vec3(2, 0.5, 1))
        // 创建车身刚体，质量为 150
        const chassisBody = new CANNON.Body({ mass: 150 })
        chassisBody.addShape(chassisShape)
        chassisBody.position.set(0, 4, 0) // 初始位置
        chassisBody.angularVelocity.set(0, 0.5, 0) // 初始角速度
        demo.addVisual(chassisBody) // 添加可视化

        // --- 创建车辆 ---
        // 使用 RaycastVehicle (射线车辆模型)
        const vehicle = new CANNON.RaycastVehicle({
          chassisBody,
        })

        // 车轮配置选项
        const wheelOptions = {
          radius: 0.5, // 车轮半径
          directionLocal: new CANNON.Vec3(0, -1, 0), // 车轮向下延伸的方向
          suspensionStiffness: 30, // 悬挂刚度
          suspensionRestLength: 0.3, // 悬挂静止长度
          frictionSlip: 1.4, // 滑动摩擦系数
          dampingRelaxation: 2.3, // 阻尼松弛
          dampingCompression: 4.4, // 阻尼压缩
          maxSuspensionForce: 100000, // 最大悬挂力
          rollInfluence: 0.01, // 侧倾影响
          axleLocal: new CANNON.Vec3(0, 0, 1), // 车轴方向
          chassisConnectionPointLocal: new CANNON.Vec3(-1, 0, 1), // 车轮连接点（相对于车身）
          maxSuspensionTravel: 0.3, // 最大悬挂行程
          customSlidingRotationalSpeed: -30, // 自定义滑动旋转速度
          useCustomSlidingRotationalSpeed: true, // 启用自定义滑动旋转速度
        }

        // 添加四个车轮
        // 左前轮
        wheelOptions.chassisConnectionPointLocal.set(-1, 0, 1)
        vehicle.addWheel(wheelOptions)

        // 左后轮
        wheelOptions.chassisConnectionPointLocal.set(-1, 0, -1)
        vehicle.addWheel(wheelOptions)

        // 右前轮
        wheelOptions.chassisConnectionPointLocal.set(1, 0, 1)
        vehicle.addWheel(wheelOptions)

        // 右后轮
        wheelOptions.chassisConnectionPointLocal.set(1, 0, -1)
        vehicle.addWheel(wheelOptions)

        // 将车辆添加到世界中
        vehicle.addToWorld(world)

        // --- 添加车轮刚体 (用于可视化和碰撞) ---
        const wheelBodies = []
        const wheelMaterial = new CANNON.Material('wheel') // 车轮材质
        vehicle.wheelInfos.forEach((wheel) => {
          // 创建圆柱体形状作为车轮
          const cylinderShape = new CANNON.Cylinder(wheel.radius, wheel.radius, wheel.radius / 2, 20)
          const wheelBody = new CANNON.Body({
            mass: 0, // 质量为0，因为它们由车辆运动学控制
            material: wheelMaterial,
          })
          wheelBody.type = CANNON.Body.KINEMATIC // 运动学物体
          wheelBody.collisionFilterGroup = 0 // 关闭碰撞，由 RaycastVehicle 处理
          const quaternion = new CANNON.Quaternion().setFromEuler(-Math.PI / 2, 0, 0)
          wheelBody.addShape(cylinderShape, new CANNON.Vec3(), quaternion)
          wheelBodies.push(wheelBody)
          demo.addVisual(wheelBody)
          world.addBody(wheelBody)
        })

        // --- 更新车轮位置 ---
        // 在每次物理步进后更新车轮刚体的位置和旋转，使其与 RaycastVehicle 的计算结果同步
        world.addEventListener('postStep', () => {
          for (let i = 0; i < vehicle.wheelInfos.length; i++) {
            vehicle.updateWheelTransform(i)
            const transform = vehicle.wheelInfos[i].worldTransform
            const wheelBody = wheelBodies[i]
            wheelBody.position.copy(transform.position)
            wheelBody.quaternion.copy(transform.quaternion)
          }
        })

        // --- 添加地面 (高度场) ---
        const sizeX = 64
        const sizeZ = 64
        const matrix = []
        // 生成高度数据
        for (let i = 0; i < sizeX; i++) {
          matrix.push([])
          for (let j = 0; j < sizeZ; j++) {
            // 边缘抬高，防止掉出
            if (i === 0 || i === sizeX - 1 || j === 0 || j === sizeZ - 1) {
              const height = 3
              matrix[i].push(height)
              continue
            }

            // 使用余弦函数生成波浪形地形
            const height = Math.cos((i / sizeX) * Math.PI * 5) * Math.cos((j / sizeZ) * Math.PI * 5) * 2 + 2
            matrix[i].push(height)
          }
        }

        const groundMaterial = new CANNON.Material('ground')
        // 创建高度场形状
        const heightfieldShape = new CANNON.Heightfield(matrix, {
          elementSize: 100 / sizeX, // 每个元素的大小
        })
        const heightfieldBody = new CANNON.Body({ mass: 0, material: groundMaterial }) // 质量为0表示静态
        heightfieldBody.addShape(heightfieldShape)
        // 设置高度场位置，使其居中
        heightfieldBody.position.set(
          -(sizeX * heightfieldShape.elementSize) / 2,
          -1,
          (sizeZ * heightfieldShape.elementSize) / 2
        )
        heightfieldBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0) // 旋转以匹配坐标系
        world.addBody(heightfieldBody)
        demo.addVisual(heightfieldBody)

        // --- 定义材质交互 ---
        // 定义车轮和地面之间的接触材质属性
        const wheel_ground = new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
          friction: 0.3, // 摩擦系数
          restitution: 0, // 恢复系数 (反弹)
          contactEquationStiffness: 1000, // 接触刚度
        })
        world.addContactMaterial(wheel_ground)

        // --- 键盘控制 ---
        // 按下按键时施加力
        document.addEventListener('keydown', (event) => {
          const maxSteerVal = 0.5 // 最大转向角
          const maxForce = 1000 // 最大引擎力
          const brakeForce = 1000000 // 刹车力

          switch (event.key) {
            case 'w':
            case 'ArrowUp':
              // 后轮驱动前进
              vehicle.applyEngineForce(-maxForce, 2)
              vehicle.applyEngineForce(-maxForce, 3)
              break

            case 's':
            case 'ArrowDown':
              // 后轮驱动后退
              vehicle.applyEngineForce(maxForce, 2)
              vehicle.applyEngineForce(maxForce, 3)
              break

            case 'a':
            case 'ArrowLeft':
              // 前轮左转
              vehicle.setSteeringValue(maxSteerVal, 0)
              vehicle.setSteeringValue(maxSteerVal, 1)
              break

            case 'd':
            case 'ArrowRight':
              // 前轮右转
              vehicle.setSteeringValue(-maxSteerVal, 0)
              vehicle.setSteeringValue(-maxSteerVal, 1)
              break

            case 'b':
              // 四轮刹车
              vehicle.setBrake(brakeForce, 0)
              vehicle.setBrake(brakeForce, 1)
              vehicle.setBrake(brakeForce, 2)
              vehicle.setBrake(brakeForce, 3)
              break
          }
        })

        // 松开按键时重置力
        document.addEventListener('keyup', (event) => {
          switch (event.key) {
            case 'w':
            case 'ArrowUp':
              vehicle.applyEngineForce(0, 2)
              vehicle.applyEngineForce(0, 3)
              break

            case 's':
            case 'ArrowDown':
              vehicle.applyEngineForce(0, 2)
              vehicle.applyEngineForce(0, 3)
              break

            case 'a':
            case 'ArrowLeft':
              vehicle.setSteeringValue(0, 0)
              vehicle.setSteeringValue(0, 1)
              break

            case 'd':
            case 'ArrowRight':
              vehicle.setSteeringValue(0, 0)
              vehicle.setSteeringValue(0, 1)
              break

            case 'b':
              vehicle.setBrake(0, 0)
              vehicle.setBrake(0, 1)
              vehicle.setBrake(0, 2)
              vehicle.setBrake(0, 3)
              break
          }
        })
      })

      demo.start()

      // 设置物理世界
      function setupWorld(demo) {
        const world = demo.getWorld()
        world.gravity.set(0, -10, 0) // 设置重力

        // 使用 Sweep and Prune 宽相算法 (性能较好)
        world.broadphase = new CANNON.SAPBroadphase(world)

        // 默认禁用摩擦力 (通过 ContactMaterial 单独设置)
        world.defaultContactMaterial.friction = 0

        return world
      }
    </script>
  </body>
</html>